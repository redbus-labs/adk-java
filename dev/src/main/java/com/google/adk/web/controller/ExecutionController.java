/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.adk.web.controller;

import com.google.adk.agents.RunConfig;
import com.google.adk.agents.RunConfig.StreamingMode;
import com.google.adk.events.Event;
import com.google.adk.runner.Runner;
import com.google.adk.web.dto.AgentRunRequest;
import com.google.adk.web.service.RunnerService;
import com.google.adk.web.service.SseEventStreamService;
import com.google.adk.web.service.eventprocessor.PassThroughEventProcessor;
import com.google.common.collect.Lists;
import io.reactivex.rxjava3.core.Flowable;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

/**
 * Controller handling agent execution endpoints.
 *
 * <p>This controller provides both non-streaming and streaming (SSE) endpoints for agent execution.
 * The SSE endpoint uses the {@link SseEventStreamService} for clean, reusable event streaming.
 *
 * <p><b>Note:</b> The default SSE endpoint is now HttpServer-based at {@code /run_sse}. This
 * Spring-based endpoint is available at {@code /run_sse_spring} for applications that prefer
 * Spring's SseEmitter.
 *
 * @author Sandeep Belgavi
 * @since January 24, 2026
 */
@RestController
public class ExecutionController {

  private static final Logger log = LoggerFactory.getLogger(ExecutionController.class);

  private final RunnerService runnerService;
  private final SseEventStreamService sseEventStreamService;
  private final PassThroughEventProcessor passThroughProcessor;

  @Autowired
  public ExecutionController(
      RunnerService runnerService,
      SseEventStreamService sseEventStreamService,
      PassThroughEventProcessor passThroughProcessor) {
    this.runnerService = runnerService;
    this.sseEventStreamService = sseEventStreamService;
    this.passThroughProcessor = passThroughProcessor;
  }

  /**
   * Executes a non-streaming agent run for a given session and message.
   *
   * @param request The AgentRunRequest containing run details.
   * @return A list of events generated during the run.
   * @throws ResponseStatusException if the session is not found or the run fails.
   */
  @PostMapping("/run")
  public List<Event> agentRun(@RequestBody AgentRunRequest request) {
    if (request.appName == null || request.appName.trim().isEmpty()) {
      log.warn("appName cannot be null or empty in POST /run request.");
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "appName cannot be null or empty");
    }
    if (request.sessionId == null || request.sessionId.trim().isEmpty()) {
      log.warn("sessionId cannot be null or empty in POST /run request.");
      throw new ResponseStatusException(
          HttpStatus.BAD_REQUEST, "sessionId cannot be null or empty");
    }
    log.info("Request received for POST /run for session: {}", request.sessionId);

    Runner runner = this.runnerService.getRunner(request.appName);
    try {

      RunConfig runConfig = RunConfig.builder().setStreamingMode(StreamingMode.NONE).build();
      Flowable<Event> eventStream =
          runner.runAsync(
              request.userId, request.sessionId, request.newMessage, runConfig, request.stateDelta);

      List<Event> events = Lists.newArrayList(eventStream.blockingIterable());
      log.info("Agent run for session {} generated {} events.", request.sessionId, events.size());
      return events;
    } catch (Exception e) {
      log.error("Error during agent run for session {}", request.sessionId, e);
      throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Agent run failed", e);
    }
  }

  /**
   * Executes an agent run and streams the resulting events using Server-Sent Events (SSE) via
   * Spring.
   *
   * <p>This endpoint uses the {@link SseEventStreamService} to provide clean, reusable SSE
   * streaming using Spring's SseEmitter. Events are sent to the client in real-time as they are
   * generated by the agent.
   *
   * <p><b>Note:</b> This is the Spring-based SSE endpoint. The default SSE endpoint is
   * HttpServer-based at {@code /run_sse} (zero dependencies). Use this endpoint if you prefer
   * Spring's framework features.
   *
   * <p><b>Request Format:</b>
   *
   * <pre>{@code
   * {
   *   "appName": "my-app",
   *   "userId": "user123",
   *   "sessionId": "session456",
   *   "newMessage": {
   *     "role": "user",
   *     "parts": [{"text": "Hello"}]
   *   },
   *   "streaming": true,
   *   "stateDelta": {"key": "value"}
   * }
   * }</pre>
   *
   * <p><b>Response:</b> Server-Sent Events stream with Content-Type: text/event-stream
   *
   * @param request The AgentRunRequest containing run details
   * @return SseEmitter that streams events to the client
   * @throws ResponseStatusException if request validation fails
   * @author Sandeep Belgavi
   * @since January 24, 2026
   */
  @PostMapping(value = "/run_sse_spring", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
  public SseEmitter agentRunSseSpring(@RequestBody AgentRunRequest request) {
    // Validate request
    if (request.appName == null || request.appName.trim().isEmpty()) {
      log.warn(
          "appName cannot be null or empty in SSE request for appName: {}, session: {}",
          request.appName,
          request.sessionId);
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "appName cannot be null or empty");
    }
    if (request.sessionId == null || request.sessionId.trim().isEmpty()) {
      log.warn(
          "sessionId cannot be null or empty in SSE request for appName: {}, session: {}",
          request.appName,
          request.sessionId);
      throw new ResponseStatusException(
          HttpStatus.BAD_REQUEST, "sessionId cannot be null or empty");
    }

    log.info(
        "Spring SSE request received for POST /run_sse_spring for session: {}", request.sessionId);

    try {
      // Get runner for the app
      Runner runner = runnerService.getRunner(request.appName);

      // Build run config
      RunConfig runConfig =
          RunConfig.builder()
              .setStreamingMode(request.getStreaming() ? StreamingMode.SSE : StreamingMode.NONE)
              .build();

      // Stream events using the service
      return sseEventStreamService.streamEvents(
          runner,
          request.appName,
          request.userId,
          request.sessionId,
          request.newMessage,
          runConfig,
          request.stateDelta,
          passThroughProcessor); // Use pass-through processor for generic endpoint

    } catch (ResponseStatusException e) {
      // Re-throw HTTP exceptions
      throw e;
    } catch (Exception e) {
      log.error(
          "Error setting up SSE stream for session {}: {}", request.sessionId, e.getMessage(), e);
      throw new ResponseStatusException(
          HttpStatus.INTERNAL_SERVER_ERROR, "Failed to setup SSE stream", e);
    }
  }
}
